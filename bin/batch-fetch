#!/usr/bin/env bash

START_TIME=$(date +%s)
MOUNT_DIR="${MOUNT_DIR:-/Volumes/Monterey}"
export HOMEBREW_NO_ENV_HINTS=1

# Default options
WINDOW_SIZE=10
RESUMABLE=false
MAX_RUNTIME=""
MAX_BATCHES=""
RESET_STATE=false
FETCH_TYPE="both"

# Parse arguments
while [[ $# -gt 0 ]]; do
	case $1 in
	--window)
		WINDOW_SIZE="$2"
		if ! [[ ${WINDOW_SIZE} =~ ^[0-9]+$ ]] || [[ ${WINDOW_SIZE} -lt 1 ]]; then
			echo "ERROR: --window must be a positive integer"
			exit 1
		fi
		shift 2
		;;
	--type)
		FETCH_TYPE="$2"
		if [[ ! ${FETCH_TYPE} =~ ^(formulae|casks|both)$ ]]; then
			echo "ERROR: --type must be one of: formulae, casks, both"
			exit 1
		fi
		shift 2
		;;
	--resumable)
		RESUMABLE=true
		shift
		;;
	--max-runtime)
		MAX_RUNTIME="$2"
		if ! [[ ${MAX_RUNTIME} =~ ^[0-9]+[hms]$ ]]; then
			echo "ERROR: --max-runtime must be in format: <number>[h|m|s] (e.g., 2h, 30m, 3600s)"
			exit 1
		fi
		shift 2
		;;
	--max-batches)
		MAX_BATCHES="$2"
		if ! [[ ${MAX_BATCHES} =~ ^[0-9]+$ ]] || [[ ${MAX_BATCHES} -lt 1 ]]; then
			echo "ERROR: --max-batches must be a positive integer"
			exit 1
		fi
		shift 2
		;;
	--reset)
		RESET_STATE=true
		shift
		;;
	--help)
		cat <<-EOF
			Usage: batch-fetch [OPTIONS] [INPUT_FILE]

			Fetch Homebrew formulae and/or casks in batches.

			OPTIONS:
			  --type <TYPE>         What to fetch: formulae, casks, or both (default: both)
			  --window <N>          Process N items per batch (default: 10)
			  --resumable           Enable resumable mode with state tracking
			  --max-runtime <TIME>  Maximum runtime (e.g., 2h, 30m, 3600s)
			  --max-batches <N>     Process at most N batches then exit
			  --reset               Clear saved state and start fresh (requires --resumable)
			  --help                Show this help message

			ARGUMENTS:
			  INPUT_FILE            File containing list of items (one per line)
			                        Default: uses _all index for current freeze commit(s)

			EXAMPLES:
			  # Fetch both formulae and casks (default)
			  batch-fetch --resumable --max-runtime 2h

			  # Fetch only formulae
			  batch-fetch --resumable --type formulae

			  # Fetch only casks
			  batch-fetch --resumable --type casks

			  # Reset state and start over
			  batch-fetch --resumable --reset

		EOF
		exit 0
		;;
	*)
		INPUT_FILE="$1"
		shift
		;;
	esac
done

# Convert max runtime to seconds
convert_to_seconds() {
	local time_str="$1"
	local value="${time_str%[hms]}"
	local unit="${time_str: -1}"

	case ${unit} in
	h) echo $((value * 3600)) ;;
	m) echo $((value * 60)) ;;
	s) echo "${value}" ;;
	esac
}

if [[ -n ${MAX_RUNTIME} ]]; then
	MAX_RUNTIME_SECONDS=$(convert_to_seconds "${MAX_RUNTIME}")
	echo "Maximum runtime: ${MAX_RUNTIME} (${MAX_RUNTIME_SECONDS} seconds)"
fi

# Get freeze commits
get_freeze_commits() {
	# Homebrew core (formulae)
	HOMEBREW_CORE_DIR="${MOUNT_DIR}/repos/homebrew-core"
	if [[ -d ${HOMEBREW_CORE_DIR} ]]; then
		FREEZE_COMMIT_CORE=$(cd "${HOMEBREW_CORE_DIR}" && git rev-parse --short HEAD 2>/dev/null)
		if [[ -z ${FREEZE_COMMIT_CORE} ]]; then
			echo "WARNING: Could not determine freeze commit from ${HOMEBREW_CORE_DIR}"
		fi
	fi

	# Homebrew cask (casks)
	HOMEBREW_CASK_DIR="${MOUNT_DIR}/repos/homebrew-cask"
	if [[ -d ${HOMEBREW_CASK_DIR} ]]; then
		FREEZE_COMMIT_CASK=$(cd "${HOMEBREW_CASK_DIR}" && git rev-parse --short HEAD 2>/dev/null)
		if [[ -z ${FREEZE_COMMIT_CASK} ]]; then
			echo "WARNING: Could not determine freeze commit from ${HOMEBREW_CASK_DIR}"
		fi
	fi
}

get_freeze_commits

# Main fetch function for a single type
fetch_type() {
	local type="$1"
	local freeze_commit=""
	local default_index=""
	local fetch_cmd_prefix=""
	local type_label=""
	
	if [[ ${type} == "formulae" ]]; then
		freeze_commit="${FREEZE_COMMIT_CORE}"
		default_index="${MOUNT_DIR}/repos/${freeze_commit}_all"
		fetch_cmd_prefix="brew fetch --deps"
		type_label="Formulae"
	else
		freeze_commit="${FREEZE_COMMIT_CASK}"
		default_index="${MOUNT_DIR}/repos/${freeze_commit}_casks_all"
		fetch_cmd_prefix="brew fetch --cask"
		type_label="Casks"
	fi

	if [[ -z ${freeze_commit} ]]; then
		echo "ERROR: Freeze commit not available for ${type}"
		return 1
	fi

	echo ""
	echo "═══════════════════════════════════════════════════════════════"
	echo "  Fetching ${type_label} (commit: ${freeze_commit})"
	echo "═══════════════════════════════════════════════════════════════"
	echo ""

	# State file for resumable mode
	STATE_FILE="${MOUNT_DIR}/repos/.batch-fetch-state-${type}-${freeze_commit}"
	LOCK_FILE="${MOUNT_DIR}/repos/.batch-fetch-lock-${type}-${freeze_commit}"

	# Lock file management
	acquire_lock() {
		if [[ -f ${LOCK_FILE} ]]; then
			local lock_pid
			lock_pid=$(cat "${LOCK_FILE}" 2>/dev/null || echo "")
			
			local lock_mtime
			if [[ "$(uname)" == "Darwin" ]]; then
				lock_mtime=$(stat -f %m "${LOCK_FILE}" 2>/dev/null || echo 0)
			else
				lock_mtime=$(stat -c %Y "${LOCK_FILE}" 2>/dev/null || echo 0)
			fi
			local lock_age=$(($(date +%s) - lock_mtime))

			if [[ -n ${lock_pid} ]] && kill -0 "${lock_pid}" 2>/dev/null; then
				echo "ERROR: Another instance is already running for ${type} (PID: ${lock_pid})"
				return 1
			elif [[ ${lock_age} -lt 86400 ]]; then
				echo "ERROR: Lock file exists for ${type} from recent run but process not found."
				echo "If you're sure no other instance is running, remove: ${LOCK_FILE}"
				return 1
			else
				echo "WARNING: Removing stale lock file for ${type} (>24 hours old)"
				rm -f "${LOCK_FILE}"
			fi
		fi

		echo $$ >"${LOCK_FILE}"
	}

	release_lock() {
		rm -f "${LOCK_FILE}"
	}

	# State management functions
	save_state() {
		if [[ ${RESUMABLE} == true ]]; then
			local current_line="$1"
			local batches_processed="$2"
			cat >"${STATE_FILE}" <<-EOFSTATE
				{
				  "type": "${type}",
				  "input_file": "${INPUT_FILE}",
				  "window_size": ${WINDOW_SIZE},
				  "last_line_processed": ${current_line},
				  "batches_processed": ${batches_processed},
				  "last_update": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
				  "freeze_commit": "${freeze_commit}"
				}
			EOFSTATE
		fi
	}

	load_state() {
		if [[ ${RESUMABLE} == true ]] && [[ -f ${STATE_FILE} ]] && [[ ${RESET_STATE} == false ]]; then
			local saved_input
			saved_input=$(grep '"input_file"' "${STATE_FILE}" | sed 's/.*": "\(.*\)".*/\1/')
			local saved_line
			saved_line=$(grep '"last_line_processed"' "${STATE_FILE}" | sed 's/.*": \([0-9]*\).*/\1/')
			local saved_batches
			saved_batches=$(grep '"batches_processed"' "${STATE_FILE}" | sed 's/.*": \([0-9]*\).*/\1/')

			if [[ ${saved_input} == "${INPUT_FILE}" ]]; then
				echo "Resuming ${type} from line ${saved_line} (${saved_batches} batches already processed)"
				echo "${saved_line}|${saved_batches}"
			else
				echo "WARNING: State file exists for ${type} but input file has changed"
				echo "Starting from beginning"
				echo "1|0"
			fi
		else
			echo "1|0"
		fi
	}

	# Acquire lock if in resumable mode
	if [[ ${RESUMABLE} == true ]]; then
		acquire_lock || return 1
		
		if [[ ${RESET_STATE} == true ]]; then
			echo "Resetting state for ${type}..."
			rm -f "${STATE_FILE}"
		fi
	fi

	# Determine input file
	if [[ -n ${INPUT_FILE} ]]; then
		if [[ ! -f ${INPUT_FILE} ]]; then
			echo "ERROR: Input file not found: ${INPUT_FILE}"
			release_lock
			return 1
		fi
		echo "Using input file: ${INPUT_FILE}"
	else
		INPUT_FILE="${default_index}"
		if [[ ! -f ${INPUT_FILE} ]]; then
			echo "ERROR: Index not found at ${INPUT_FILE}"
			release_lock
			return 1
		fi
		echo "Using default index for ${type}"
	fi

	# Load state if resumable
	state_data=$(load_state)
	start_line=$(echo "${state_data}" | cut -d'|' -f1)
	batches_completed=$(echo "${state_data}" | cut -d'|' -f2)

	# Initialize CSV results file
	FETCH_RESULTS="${MOUNT_DIR}/repos/${freeze_commit}_${type}_fetch_results"
	FETCH_RESULTS_NEW=$(mktemp)

	if [[ ! -f ${FETCH_RESULTS} ]]; then
		if [[ ${type} == "formulae" ]]; then
			echo "# fields: formula,bottle,source,platform-specific,error" >"${FETCH_RESULTS}"
		else
			echo "# fields: cask,downloaded,error" >"${FETCH_RESULTS}"
		fi
	fi

	# Function to add result
	add_fetch_result() {
		if [[ ${type} == "formulae" ]]; then
			local formula="$1"
			local has_bottle="$2"
			local has_source="$3"
			local platform_specific="$4"
			local error_msg="$5"
			formula="${formula#homebrew/core/}"
			error_msg="${error_msg//,/;}"
			echo "${formula},${has_bottle},${has_source},${platform_specific},${error_msg}" >>"${FETCH_RESULTS_NEW}"
		else
			local cask="$1"
			local downloaded="$2"
			local error_msg="$3"
			cask="${cask#homebrew/cask/}"
			error_msg="${error_msg//,/;}"
			echo "${cask},${downloaded},${error_msg}" >>"${FETCH_RESULTS_NEW}"
		fi
	}

	echo "Window size: ${WINDOW_SIZE} items per batch"

	# Get cache directory
	CACHE_DIR="$(brew --cache)/downloads"

	# Recursive function to fetch a batch
	fetch_batch() {
		local batch="$1"
		local indent="$2"
		local count
		count=$(echo "${batch}" | wc -w | tr -d ' ')

		if [[ ${count} -eq 0 ]]; then
			return 0
		fi

		# Pre-check cache
		local already_cached=()
		local need_fetch=()

		for item in ${batch}; do
			if [[ ${type} == "formulae" ]]; then
				if find "${CACHE_DIR}" -name "*--${item}--*.bottle*.tar.gz" -print -quit 2>/dev/null | grep -q .; then
					already_cached+=("${item}")
					add_fetch_result "${item}" "true" "false" "false" ""
				else
					need_fetch+=("${item}")
				fi
			else
				# For casks, check for any download artifact
				if find "${CACHE_DIR}" -name "*${item}*" -print -quit 2>/dev/null | grep -q .; then
					already_cached+=("${item}")
					add_fetch_result "${item}" "true" ""
				else
					need_fetch+=("${item}")
				fi
			fi
		done

		# Report cached
		if [[ ${#already_cached[@]} -gt 0 ]]; then
			echo "${indent}↻ Already cached ${#already_cached[@]} ${type}" >&2
		fi

		if [[ ${#need_fetch[@]} -eq 0 ]]; then
			return 0
		fi

		local fetch_batch_str="${need_fetch[*]}"

		# Try batch fetch
		local fetch_error
		# shellcheck disable=SC2086
		if fetch_error=$(${fetch_cmd_prefix} ${fetch_batch_str} 2>&1); then
			# Success - verify what was downloaded
			for item in ${fetch_batch_str}; do
				if [[ ${type} == "formulae" ]]; then
					if find "${CACHE_DIR}" -name "*--${item}--*.bottle*.tar.gz" -print -quit 2>/dev/null | grep -q .; then
						add_fetch_result "${item}" "true" "false" "false" ""
						echo "${indent}✓ ${item}" >&2
					else
						add_fetch_result "${item}" "false" "false" "false" "No bottle found"
						echo "${indent}⚠ ${item} (no bottle)" >&2
					fi
				else
					if find "${CACHE_DIR}" -name "*${item}*" -print -quit 2>/dev/null | grep -q .; then
						add_fetch_result "${item}" "true" ""
						echo "${indent}✓ ${item}" >&2
					else
						add_fetch_result "${item}" "false" "Not downloaded"
						echo "${indent}⚠ ${item} (not downloaded)" >&2
					fi
				fi
			done
			return 0
		fi

		# Parse error to find failed item
		local failed
		failed=$(echo "${fetch_error}" | sed -n 's/^Error: \([^:]*\):.*/\1/p' | head -1)

		if [[ -n ${failed} ]]; then
			echo "${indent}✗ Failed: ${failed}" >&2
			
			local error_message
			error_message=$(echo "${fetch_error}" | grep "^Error:" | head -1 | sed 's/^Error: [^:]*: //')
			
			if [[ ${type} == "formulae" ]]; then
				add_fetch_result "${failed}" "false" "false" "false" "${error_message}"
			else
				add_fetch_result "${failed}" "false" "${error_message}"
			fi

			# Remove failed and retry
			local failed_name="${failed#homebrew/core/}"
			failed_name="${failed_name#homebrew/cask/}"
			local remaining
			remaining=$(echo "${fetch_batch_str}" | tr ' ' '\n' | grep -v -e "^${failed}$" -e "^${failed_name}$" | tr '\n' ' ')
			
			local remaining_count
			remaining_count=$(echo "${remaining}" | wc -w | tr -d ' ')

			if [[ ${remaining_count} -ge ${count} ]]; then
				echo "${indent}ERROR: Could not remove failed item, aborting" >&2
				return 1
			fi

			if [[ ${remaining_count} -gt 0 ]]; then
				echo "${indent}→ Retrying with ${remaining_count} items..." >&2
				fetch_batch "${remaining}" "${indent}  "
			fi
		else
			# Try individually
			echo "${indent}Trying individually..." >&2
			for item in ${fetch_batch_str}; do
				local individual_error
				if individual_error=$(${fetch_cmd_prefix} "${item}" 2>&1); then
					echo "${indent}  ✓ ${item}" >&2
					if [[ ${type} == "formulae" ]]; then
						add_fetch_result "${item}" "true" "false" "false" ""
					else
						add_fetch_result "${item}" "true" ""
					fi
				else
					echo "${indent}  ✗ ${item}" >&2
					local error_message
					error_message=$(echo "${individual_error}" | grep "^Error:" | head -1 | sed 's/^Error: [^:]*: //')
					if [[ ${type} == "formulae" ]]; then
						add_fetch_result "${item}" "false" "false" "false" "${error_message}"
					else
						add_fetch_result "${item}" "false" "${error_message}"
					fi
				fi
			done
		fi
	}

	# Signal handlers
	interrupted=false
	handle_signal() {
		echo "" >&2
		echo "Received interrupt signal for ${type}, finishing current batch..." >&2
		interrupted=true
	}

	trap handle_signal SIGINT SIGTERM

	# Main fetch loop
	start=${start_line}
	end=$((start_line + WINDOW_SIZE - 1))
	batches_processed=0

	while true; do
		if [[ ${interrupted} == true ]]; then
			echo "" >&2
			echo "Interrupted ${type} - saving state and exiting..." >&2
			break
		fi

		if [[ -n ${MAX_RUNTIME_SECONDS} ]]; then
			elapsed=$(($(date +%s) - START_TIME))
			if [[ ${elapsed} -ge ${MAX_RUNTIME_SECONDS} ]]; then
				echo "" >&2
				echo "Maximum runtime reached for ${type} - saving state and exiting..." >&2
				break
			fi
		fi

		if [[ -n ${MAX_BATCHES} ]] && [[ ${batches_processed} -ge ${MAX_BATCHES} ]]; then
			echo "" >&2
			echo "Maximum batches reached for ${type} - saving state and exiting..." >&2
			break
		fi

		sed_cmd="${start},${end}p"
		lines=$(sed -n "${sed_cmd}" "${INPUT_FILE}")
		if [[ -z ${lines} ]]; then
			echo "" >&2
			echo "All ${type} processed!" >&2
			if [[ ${RESUMABLE} == true ]]; then
				rm -f "${STATE_FILE}"
			fi
			break
		fi

		line_count=$(echo "${lines}" | wc -w | tr -d ' ')
		echo "" >&2
		echo "Fetching ${type} for lines ${start} to ${end} (${line_count} items)..." >&2
		fetch_batch "${lines}" "  "

		batches_processed=$((batches_processed + 1))
		
		if [[ ${RESUMABLE} == true ]]; then
			save_state "${end}" "$((batches_completed + batches_processed))"
		fi

		start=$((start + WINDOW_SIZE))
		end=$((end + WINDOW_SIZE))
	done

	# Merge results
	echo "" >&2
	echo "Merging ${type} results..." >&2

	FETCH_RESULTS_MERGED=$(mktemp)
	head -n 1 "${FETCH_RESULTS}" >"${FETCH_RESULTS_MERGED}"

	EXISTING_TEMP=$(mktemp)
	grep -v '^#' "${FETCH_RESULTS}" >"${EXISTING_TEMP}" 2>/dev/null || true

	UPDATED_TEMP=$(mktemp)
	while IFS= read -r line; do
		item=$(echo "${line}" | cut -d',' -f1)
		echo "${item}" >>"${UPDATED_TEMP}"
	done <"${FETCH_RESULTS_NEW}"

	COMBINED_TEMP=$(mktemp)
	cat "${FETCH_RESULTS_NEW}" >>"${COMBINED_TEMP}"

	while IFS= read -r line; do
		item=$(echo "${line}" | cut -d',' -f1)
		if ! grep -qxF "${item}" "${UPDATED_TEMP}"; then
			echo "${line}" >>"${COMBINED_TEMP}"
		fi
	done <"${EXISTING_TEMP}"

	sort -t',' -k1,1 "${COMBINED_TEMP}" >>"${FETCH_RESULTS_MERGED}"
	mv "${FETCH_RESULTS_MERGED}" "${FETCH_RESULTS}"

	rm -f "${FETCH_RESULTS_NEW}" "${EXISTING_TEMP}" "${UPDATED_TEMP}" "${COMBINED_TEMP}"

	# Summary
	echo "" >&2
	echo "=== ${type_label} Summary ===" >&2
	TOTAL_RESULTS=$(grep -v '^#' "${FETCH_RESULTS}" | wc -l | tr -d ' ')
	echo "Results saved to: ${FETCH_RESULTS}" >&2
	echo "Total ${type} processed: ${TOTAL_RESULTS}" >&2
	echo "Batches processed this run: ${batches_processed}" >&2

	if [[ ${RESUMABLE} == true ]]; then
		if [[ -f ${STATE_FILE} ]]; then
			echo "State saved to: ${STATE_FILE}" >&2
			echo "Run again to resume from line $((end + 1))" >&2
		fi
	fi

	release_lock
}

# Main execution
echo "Fetch type: ${FETCH_TYPE}"

case ${FETCH_TYPE} in
	formulae)
		fetch_type "formulae"
		;;
	casks)
		fetch_type "casks"
		;;
	both)
		echo "Fetching both formulae and casks sequentially..."
		fetch_type "formulae"
		FORMULAE_RESULT=$?
		fetch_type "casks"
		CASKS_RESULT=$?
		if [[ ${FORMULAE_RESULT} -ne 0 ]] || [[ ${CASKS_RESULT} -ne 0 ]]; then
			exit 1
		fi
		;;
esac

# Final elapsed time
elapsed=$(($(date +%s) - START_TIME))
echo "" >&2
echo "Total runtime: ${elapsed} seconds ($((elapsed / 60)) minutes)" >&2
