#!/usr/bin/env bash

set -e

# === FUNCTIONS ===
cleanup() {
    if [ "${MOUNTED_IN_SCRIPT:-false}" = "true" ] && [ -n "${MOUNT_PATH:-}" ]; then
        echo "  Cleaning up mount: $MOUNT_PATH" >&2
        hdiutil detach "$MOUNT_PATH" 2>/dev/null || true
    fi
    rm -f /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress 2>/dev/null || true
}

kill_installer_and_tail() {
    if [ -n "${TAIL_PID:-}" ]; then
        kill $TAIL_PID 2>/dev/null || true
        wait $TAIL_PID 2>/dev/null || true
    fi
    if [ -n "${INSTALLER_PID:-}" ]; then
        sudo kill $INSTALLER_PID 2>/dev/null || true
        wait $INSTALLER_PID 2>/dev/null || true
    fi
}

handle_interrupt() {
    echo ""
    echo "  Caught Ctrl-C, stopping..."
    kill_installer_and_tail
    cleanup
    
    # Reset terminal
    printf "\033[?25h\033[?7h\033[r" >&2
    exit 130
}

is_installed() {
    pkgutil --pkg-info com.apple.pkg.CLTools_Executables &>/dev/null || \
    [ -e "/Library/Developer/CommandLineTools/usr/bin/clang" ]
}

# === MAIN ===
main() {
    # === SETUP PHASE ===
    clear
    
    # Print header (this stays fixed at top)
    cat << 'EOF'
═══════════════════════════════════════════════════════════════
              Command Line Tools Installation
═══════════════════════════════════════════════════════════════

EOF
    
    # Architecture detection
    ARCH=$(uname -m)
    PROC=$([[ "$ARCH" == "arm64" ]] && echo "ARM" || echo "Intel")
    echo "Architecture: $ARCH, Processor: $PROC"
    
    # === ARGUMENT HANDLING ===
    DMG_PATH=""
    if [ -n "${1:-}" ] && [ "$1" != "--no-progress" ]; then
        DMG_PATH="$1"
    fi
    
    # Default DMG path handling
    if [ -z "$DMG_PATH" ]; then
        SCRIPT_DIR="$( cd "$( dirname "$0" )" && pwd )"
        MOUNT="$( cd "${SCRIPT_DIR}/.." && pwd )"
        DMG_PATH=$(find "${MOUNT}/software/${PROC}" -name "Command_Line_Tools_*.dmg" -type f | head -n1)
    fi
    
    echo "Using DMG: $DMG_PATH"
    
    # Validate DMG
    if [ ! -f "$DMG_PATH" ]; then 
        echo "✗ Error: DMG not found at $DMG_PATH" >&2
        exit 1
    fi
    
    if [ ! -r "$DMG_PATH" ]; then
        echo "✗ Error: DMG not readable" >&2
        ls -la "$DMG_PATH" >&2
        exit 1
    fi

    # Simple mode
    if [ "${1:-}" = "--no-progress" ]; then
        if is_installed; then
            echo "✓ Command Line Tools already installed."
            exit 0
        fi
        
        echo ""
        echo "Running in simple mode..."
        
        # Mount DMG
        echo "  • Mounting DMG..."
        MOUNT_PATH="/Volumes/CLT_$$"
        hdiutil mount -readonly -quiet -nobrowse -mountpoint "$MOUNT_PATH" "$DMG_PATH" || {
            echo "  ✗ Mount failed" >&2
            exit 1
        }
        
        PKG_PATH=$(find "$MOUNT_PATH" -name "*.pkg" -type f | head -n1)
        
        # Run installer with direct output
        echo "  • Running installer..."
        sudo installer -pkg "$PKG_PATH" -target / -verboseR
        
        hdiutil detach "$MOUNT_PATH" 2>/dev/null || true
        
        # Check if installed
        if is_installed; then
            echo "  ✓ Command Line Tools installed successfully!"
        else
            echo "  ✗ Installation failed" >&2
            exit 1
        fi
        
        exit 0
    fi

    # Check if already installed
    if is_installed; then
        echo "✓ Command Line Tools already installed."
        if path=$(xcode-select --print-path 2>/dev/null); then
            echo "  Path: $path"
        fi
        exit 0
    fi

    echo "✓ Command Line Tools not detected. Proceeding with installation..."
    echo ""
    
    # Set up Ctrl-C trap BEFORE any background processes
    trap handle_interrupt SIGINT
    
    # Create progress file
    echo "  • Creating progress indicator file..."
    sudo touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
    
    # Clean up existing mounts
    echo "  • Checking for existing mounts..."
    MOUNTED_IN_SCRIPT=false
    EXISTING_MOUNTS=$(hdiutil info | grep -B 5 "$DMG_PATH" | grep '^/Volumes/' | awk '{print $NF}' || true)
    
    if [ -n "$EXISTING_MOUNTS" ]; then
        echo "  • Unmounting existing mounts..."
        echo "$EXISTING_MOUNTS" | while IFS= read -r mount_point; do
            if [ -n "$mount_point" ]; then
                echo "    - $mount_point"
                hdiutil detach "$mount_point" 2>/dev/null || true
            fi
        done
        sleep 2
    fi
    
    # Mount DMG
    echo "  • Mounting DMG..."
    MOUNT_PATH="/Volumes/CLT_$$"
    
    if ! hdiutil mount -readonly -quiet -nobrowse -mountpoint "$MOUNT_PATH" "$DMG_PATH"; then
        echo "  • Mount failed. Trying standard attach..." >&2
        MOUNT_OUTPUT=$(hdiutil attach -nobrowse "$DMG_PATH" 2>&1)
        
        if [ $? -ne 0 ]; then
            echo "  ✗ ERROR: Failed to mount DMG" >&2
            exit 1
        fi
        
        MOUNTED_IN_SCRIPT=true
        MOUNT_PATH=$(echo "$MOUNT_OUTPUT" | grep '/Volumes/' | awk '{print $NF}' | tail -n1)
        
        if [ -z "$MOUNT_PATH" ]; then
            sleep 1
            MOUNT_PATH=$(find /Volumes -maxdepth 1 -type d -name "*Command*Line*" | head -n1)
        fi
    else
        MOUNTED_IN_SCRIPT=true
    fi
    
    if [ ! -d "$MOUNT_PATH" ]; then
        echo "  ✗ ERROR: Mount point doesn't exist: $MOUNT_PATH" >&2
        exit 1
    fi
    
    echo "  • Mounted at: $MOUNT_PATH"
    
    # Find package
    PKG_PATH=$(find "$MOUNT_PATH" -maxdepth 1 -name "*.pkg" -type f | head -n1)
    if [ -z "$PKG_PATH" ]; then
        echo "  ✗ ERROR: No .pkg file found in $MOUNT_PATH" >&2
        exit 1
    fi
    
    # === SCROLLING WINDOW WITH STATIC HEADER ===
    LOG_FILE="/tmp/clt_install_$(date +%Y%m%d_%H%M%S).log"
    echo "  • Installing: $(basename "$PKG_PATH")"
    echo "  • Log file: $LOG_FILE"
    echo ""
    
    # Get terminal dimensions
    TOTAL_LINES=$(tput lines 2>/dev/null || echo 25)
    # Reserve space: header (3 lines) + setup info (8-10 lines) + window (10 lines)
    WINDOW_START_LINE=12  # Fixed position for window start
    WINDOW_HEIGHT=$((TOTAL_LINES - WINDOW_START_LINE))  # Use remaining lines
    
    # Content height (log lines only, excluding header/footer)
    CONTENT_HEIGHT=$((WINDOW_HEIGHT - 5))  # 3 lines header + 2 lines footer
    
    # Set scrolling region from WINDOW_START_LINE to bottom
    printf "\033[${WINDOW_START_LINE};${TOTAL_LINES}r"
    
    # Move to window start and print STATIC header (done once)
    printf "\033[${WINDOW_START_LINE};0H"
    cat << EOF
═══════════════════════════════════════════════════════════════
              LIVE INSTALLATION PROGRESS
═══════════════════════════════════════════════════════════════
EOF
    
    # Start installer in background
    sudo installer -pkg "$PKG_PATH" -target / -verboseR > "$LOG_FILE" 2>&1 &
    INSTALLER_PID=$!
    
    # Tail process that updates ONLY the scrollable content area
    {
        sleep 2
        
        # Display function - only updates content, not header/footer
        display_content() {
            # Move to start of content area (line after header)
            printf "\033[$((WINDOW_START_LINE + 3));0H\033[J"
            
            # Show log lines (fill content area)
            if [ -f "$LOG_FILE" ]; then
                tail -n $CONTENT_HEIGHT "$LOG_FILE" 2>/dev/null || echo "Waiting..."
            else
                echo "Waiting for installer to start..."
            fi
            
            # Move to footer position (fixed at bottom of window)
            printf "\033[$((WINDOW_START_LINE + WINDOW_HEIGHT - 2));0H"
            echo "───────────────────────────────────────────────────────────────"
            
            printf "\033[$((WINDOW_START_LINE + WINDOW_HEIGHT - 1));0H"
            echo " PID: $INSTALLER_PID | Press Ctrl+C to cancel"
        }
        
        # Initial display
        display_content
        
        # Track last line count to avoid unnecessary redraws
        LAST_LINE_COUNT=0
        
        while kill -0 "$INSTALLER_PID" 2>/dev/null; do
            if [ -f "$LOG_FILE" ]; then
                CURRENT_LINE_COUNT=$(wc -l < "$LOG_FILE")
                
                if [ $CURRENT_LINE_COUNT -gt $LAST_LINE_COUNT ]; then
                    display_content
                    LAST_LINE_COUNT=$CURRENT_LINE_COUNT
                fi
            fi
            
            sleep 0.5
        done
        
        # Final display
        display_content
        
    } &
    
    TAIL_PID=$!
    
    # Wait for installer
    wait "$INSTALLER_PID"
    INSTALL_RESULT=$?
    
    # Reset scrolling region
    printf "\033[r"
    
    # Clean up tail
    kill "$TAIL_PID" 2>/dev/null
    wait "$TAIL_PID" 2>/dev/null
    
    # Clear and show final status
    printf "\033[2J\033[H"
    
    if [ $INSTALL_RESULT -ne 0 ]; then
        echo "✗ ERROR: Installer failed" >&2
        exit 1
    fi
    
    # Verify
    if is_installed; then
        echo "✅ Command Line Tools installed successfully!"
        if path=$(xcode-select --print-path 2>/dev/null); then
            echo "Path: $path"
        fi
    else
        echo "❌ Verification failed" >&2
        exit 1
    fi
    
    echo "Full log: $LOG_FILE"
}

trap cleanup EXIT
main "$@"

